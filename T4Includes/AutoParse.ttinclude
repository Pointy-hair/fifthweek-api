<#@ include file="VisualStudioHelper.ttinclude" once="true" #>
<#@ include file="VisualStudioHelper2.ttinclude" once="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

<#
	var StrongPropertySuffix = "Object";
	var ConstructedAttributeName = "Constructed";
	var ParsedAttributeName = "Parsed";

    foreach(UnifiedClass unifiedClass in allClasses)
    {
        var publicProperties = unifiedClass.GetAllPublicGetters();
        var stronglyTypedProperties = publicProperties
			.Select(p => new { Property = p, Attribute = p.Attributes.OfType<CodeAttribute>().FirstOrDefault(_ => _.Name.StartsWith(ParsedAttributeName) || _.Name.StartsWith(ConstructedAttributeName)) })
			.Where(p => p.Attribute != null)
			.ToList();
		if (stronglyTypedProperties.Count == 0)
        {
            continue;
        }

		unifiedClass.WriteNamespaceAndClass(() => {

	// Render the main class here. Companion class follows in next lambda.

    for (var i = 0; i < stronglyTypedProperties.Count; i++)
    {
		var codeAttribute = stronglyTypedProperties[i].Attribute;
        var codeProperty = stronglyTypedProperties[i].Property;
		var typedPropertyName = codeProperty.Name + StrongPropertySuffix;
		var strongType = StripTypeOf(codeAttribute.Value);

#>
		public <#= strongType #> <#= typedPropertyName #> { get; set; }
<#
    }
#>

		public void Parse()
		{
			<#= unifiedClass.CompanionClassName #>.Parse(this); // Avoid conflicts between property and type names.
		}
<#
        }, () => { // Companion class.
#>
		public static void Parse(<#= unifiedClass.FirstCodeClass.Name #> target)
		{
			var modelStateDictionary = new System.Web.Http.ModelBinding.ModelStateDictionary();

<#
	for (var i = 0; i < stronglyTypedProperties.Count; i++)
	{
		var codeAttribute = stronglyTypedProperties[i].Attribute;
        var codeProperty = stronglyTypedProperties[i].Property;
		var typedPropertyName = codeProperty.Name + StrongPropertySuffix;
		var strongType = StripTypeOf(codeAttribute.Value);
		var isRequired = codeProperty.Attributes.OfType<CodeAttribute>().All(_ => !_.Name.StartsWith(OptionalAttributeName));

		if (codeAttribute.Name.StartsWith(ConstructedAttributeName))
        {
#>
			target.<#= typedPropertyName #> = new <#= strongType #>(target.<#= codeProperty.Name #>);
<#
        }
		else
        {
#>
			if (<#= isRequired ? "true" : "false" #> || !<#= strongType #>.IsEmpty(target.<#= codeProperty.Name #>))
			{
				<#= strongType #> @object;
				System.Collections.Generic.IReadOnlyCollection<string> errorMessages;
				if (<#= strongType #>.TryParse(target.<#= codeProperty.Name #>, out @object, out errorMessages))
				{
					target.<#= typedPropertyName #> = @object;
				}
				else
				{
					var modelState = new System.Web.Http.ModelBinding.ModelState();
					foreach (var errorMessage in errorMessages)
					{
						modelState.Errors.Add(errorMessage);
					}

					modelStateDictionary.Add("<#= codeProperty.Name #>", modelState);
				}
			}

<#
        }
	}
#>
			if (!modelStateDictionary.IsValid)
			{
				throw new Fifthweek.Api.Core.ModelValidationException(modelStateDictionary);
			}
		}	
<#
		});
    }
#>
