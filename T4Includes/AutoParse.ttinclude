<#@ include file="VisualStudioHelper.ttinclude" once="true" #>
<#@ include file="VisualStudioHelper2.ttinclude" once="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	var ParsedCounterpartAttributeName = "ParsedCounterpart";

    foreach(var unifiedClass in UnifiedClassesInProject.Values)
    {
        var publicProperties = unifiedClass.GetAllPublicGetters();
        var stronglyTypedProperties = publicProperties
            .Select(p => new { Property = p, ParseInstructions = ParseInstructions.TryGetForProperty(p) })
            .Where(p => p.ParseInstructions != null)
            .ToList();
        if (stronglyTypedProperties.Count == 0)
        {
            continue;
        }

		var generateCounterpartType = true;
		var counterpartType = unifiedClass.FirstCodeClass.Name + ".Parsed";
		var allAttributes = unifiedClass.GetAllAttributes();
		var parsedCounterpartAttribute = allAttributes.FirstOrDefault(_ => _.Name.StartsWith(ParsedCounterpartAttributeName));
        if (parsedCounterpartAttribute != null)
        {
            var attributeParameters = ParseAttribute(parsedCounterpartAttribute.Value);
			counterpartType = StripTypeOf(attributeParameters[0]);
			generateCounterpartType = false;
        }

		var parameters = AutoConstructorParameter.GetParametersForClass(unifiedClass);
		foreach (var parameter in parameters)
        {
			var stonglyTypedProperty = stronglyTypedProperties.SingleOrDefault(_ => _.Property.Name == parameter.AssigneeName);
			if (stonglyTypedProperty != null)
            {
				parameter.TypeName = stonglyTypedProperty.ParseInstructions.ParsedType;
            }
        }

        unifiedClass.WriteNamespaceAndClass(() => {
			if (generateCounterpartType)
			{
#>
public class Parsed
{
<# 
	this.PushIndent(Tab);
	RenderConstructor("Parsed", parameters, this); 
	this.PopIndent();

    // Render the main class here. Companion class follows in next lambda.
    foreach (var parameter in parameters)
    {
#>

    public <#= parameter.TypeName #> <#= parameter.AssigneeName #> { get; private set; }
<#
    }
#>
}
<#
			}
        }, () => { // Extension class. Avoid conflicts between property and type names.
#>
public static <#= counterpartType #> Parse(this <#= unifiedClass.FirstCodeClass.Name #> target)
{
    var modelStateDictionary = new System.Web.Http.ModelBinding.ModelStateDictionary();

<#
    for (var i = 0; i < stronglyTypedProperties.Count; i++)
    {
        var parseInstructions = stronglyTypedProperties[i].ParseInstructions;
        var codeProperty = stronglyTypedProperties[i].Property;
        var isRequired = codeProperty.Attributes.OfType<CodeAttribute>().All(_ => !_.Name.StartsWith(OptionalAttributeName));
		var variableName = "parsed" + i;

		this.PushIndent(Tab);
		RenderParseBlock(
			parseInstructions, 
			codeProperty, 
			variableName, 
			isRequired, 
			this,
			unifiedClass);
		this.PopIndent();
    }
#>
    if (!modelStateDictionary.IsValid)
    {
        throw new Fifthweek.Api.Core.ModelValidationException(modelStateDictionary);
    }

    return new <#= counterpartType #>(
<#
	this.PushIndent(Tab);
	this.PushIndent(Tab);
	var parsedIndex = 0;
	for (var i = 0; i < parameters.Count; i++)
    {
		var parameter = parameters[i];
		var stonglyTypedProperty = stronglyTypedProperties.SingleOrDefault(_ => _.Property.Name == parameter.AssigneeName);
		if (stonglyTypedProperty != null)
        {
			this.Write("parsed" + parsedIndex++);
        }
		else
        {
			this.Write("target." + parameter.AssigneeName);
        }

		if (i < parameters.Count - 1)
        {
			this.WriteLine(",");
        }
		else
        {
			this.WriteLine(");");
        }
    }

	this.PopIndent();
	this.PopIndent();
#>
}    
<#
        });
    }
#>
<#+
	public const string StaticIsEmptyMethodName = "IsEmpty";
	public const string ParsedAttributeName = "Parsed";
	public const string ParsedElementsAttributeName = "ParsedElements";
	public const string NewModelState = "var modelState = new System.Web.Http.ModelBinding.ModelState();";

	public static void RenderParseBlock(
		ParseInstructions parseInstructions, 
		CodeProperty property, 
		string variable, 
		bool isRequired, 
		TextTransformation output,
		UnifiedClass unifiedClass)
	{
		var targetProperty = "target." + property.Name;
		var nonIndexedFieldName = string.Format("\"{0}\"", property.Name);

		if (parseInstructions.ParsedElementType != null)
        {
			var listType = "System.Collections.Generic.List<" + parseInstructions.ParsedElementType + ">";
			string bufferName;
			if (parseInstructions.ParsedOuterType != null)
            {
				bufferName = variable + "Buffer";
            }
			else
            {
				bufferName = variable;
            }

			output.WriteLine(listType + " " + bufferName + " = null;");
            output.WriteLine("if (" + targetProperty + " != null)");
            output.WriteLine("{");
			output.PushIndent(Tab);

			output.WriteLine(bufferName + " = new " + listType + "();");
			output.WriteLine("for (var i = 0; i < " + targetProperty + ".Count; i++)");
			output.WriteLine("{");
			output.PushIndent(Tab);

			var elementType = GetGenericParameters(property.Type.CodeType.FullName)[0];
			RenderInnerParseBlock(
				parseInstructions.ParsedElementType, 
				string.Format("\"{0}[\" + i + \"]\"", property.Name), 
				"target." + property.Name + "[i]", 
				"parsedElement", 
				true, 
				true,
				elementType, 
				output,
				unifiedClass);

			output.WriteLine("if (parsedElement != null)");
			output.WriteLine("{");
			output.PushIndent(Tab);
			output.WriteLine(bufferName + ".Add(parsedElement);");
			output.PopIndent();
			output.WriteLine("}");

			output.PopIndent();
			output.WriteLine("}");
			output.PopIndent();
			output.WriteLine("}");
			
			if (parseInstructions.ParsedOuterType != null)
            {
				// Null check is taken care of for us by the following parse block.
				output.WriteLine("");
				output.WriteLine(parseInstructions.ParsedOuterType + " " + variable + " = null;");
				
				RenderInnerParseBlock(
					parseInstructions.ParsedOuterType, 
					nonIndexedFieldName, 
					bufferName, 
					variable, 
					isRequired, 
					false,
					parseInstructions.ParsedElementType, 
					output,
					unifiedClass);
            }
			else if (isRequired)
            {
				// Need to raise valid required violation if list is null.
				var addModelState = string.Format("modelStateDictionary.Add({0}, modelState);",  nonIndexedFieldName);
				RenderElseValueRequired(addModelState, output);
				output.WriteLine("");
            }
			else
			{
				output.WriteLine("");
            }
        }
		else
        {
			RenderInnerParseBlock(
				parseInstructions.ParsedOuterType, 
				nonIndexedFieldName, 
				targetProperty, 
				variable, 
				isRequired, 
				true,
				property.Type.CodeType.FullName, 
				output,
				unifiedClass);
        }
    }

	public static void RenderInnerParseBlock(
		string strongType, 
		string fieldName, 
		string accessor, 
		string variable, 
		bool isRequired, 
		bool declareVariable,
		string accessorType,
		TextTransformation output,
		UnifiedClass unifiedClass)
	{
		var hasCustomEmptyCheck = HasCustomEmptyCheck(strongType, unifiedClass);
		var isNullableValue = IsNullablePrimitiveType(accessorType);
		var isReferenceType = IsReferenceType(accessorType);
		
		var addModelState = string.Format("modelStateDictionary.Add({0}, modelState);",  fieldName);

		if (declareVariable)
        {
			output.WriteLine(string.Format("{0} {1} = null;", strongType, variable));
        }

		var valueAccessor = isNullableValue ? accessor + ".Value" : accessor;
		if (hasCustomEmptyCheck)
        {
			output.WriteLine(string.Format("if (!{0}.IsEmpty({1}))", strongType, valueAccessor));
			output.WriteLine("{");
			output.PushIndent(Tab);
        }
		else if (isReferenceType)
        {
			output.WriteLine(string.Format("if ({0} != null)", accessor));
			output.WriteLine("{");
			output.PushIndent(Tab);
        }

		output.WriteLine(string.Format("System.Collections.Generic.IReadOnlyCollection<string> {0}Errors;", variable));
		output.WriteLine(string.Format("if (!{0}.TryParse({1}, out {2}, out {2}Errors))", strongType, valueAccessor, variable));
		output.WriteLine("{");
		output.PushIndent(Tab);
        
		output.WriteLine(NewModelState);
		output.WriteLine(string.Format("foreach (var errorMessage in {0}Errors)", variable));
        output.WriteLine("{");
		output.PushIndent(Tab);
		output.WriteLine("modelState.Errors.Add(errorMessage);");
        output.PopIndent();
		output.WriteLine("}");
		output.WriteLine("");
        output.WriteLine(addModelState);

		output.PopIndent();
		output.WriteLine("}");

		if (hasCustomEmptyCheck) 
        {
			output.PopIndent();
			output.WriteLine("}");

			if (isRequired)
			{
				RenderElseValueRequired(addModelState, output);
			}
		}
		else if (isReferenceType)
        {
			output.PopIndent();
			output.WriteLine("}");

			if (isRequired)
			{
				RenderElseValueRequired(addModelState, output);
			}
        }

		output.WriteLine("");
	}

	public static void RenderElseValueRequired(string addModelState, TextTransformation output)
	{
		output.WriteLine("else");
		output.WriteLine("{");
		output.PushIndent(Tab);
		output.WriteLine(NewModelState);
		output.WriteLine("modelState.Errors.Add(\"Value required\");");
		output.WriteLine(addModelState);
		output.PopIndent();
		output.WriteLine("}");
	}

	public static bool HasCustomEmptyCheck(string shortTypeName, UnifiedClass unifiedClass)
    {
		var strongTypeUnifiedClass = unifiedClass.ResolveUnifiedClass(shortTypeName);
		return strongTypeUnifiedClass.GetAllPublicMethods().Any(_ => _.IsShared && _.Name == StaticIsEmptyMethodName);
    }

	public class ParseInstructions
    {
		private ParseInstructions()
        {
        }

		public string ParsedOuterType { get; private set; }
		public string ParsedElementType { get; private set; }

		public string ParsedType
        {
			get
            {
				if (this.ParsedOuterType != null)
                {
					return this.ParsedOuterType;
                }
				else
                {
					return string.Format("System.Collections.Generic.IReadOnlyList<{0}>", this.ParsedElementType);
                }
            }
        }

		public static ParseInstructions TryGetForProperty(CodeProperty property)
        {
			var parsedAttribute = property.Attributes.OfType<CodeAttribute>().FirstOrDefault(_ => _.Name == ParsedAttributeName);
			var parsedElementsAttribute = property.Attributes.OfType<CodeAttribute>().FirstOrDefault(_ => _.Name == ParsedElementsAttributeName);

			if (parsedAttribute == null && parsedElementsAttribute == null)
            {
				return null;
            }

			return new ParseInstructions
            {
				ParsedOuterType = parsedAttribute == null ? null : GetTypeParameter(parsedAttribute),
				ParsedElementType = parsedElementsAttribute == null ? null : GetTypeParameter(parsedElementsAttribute)
            };
        }

		private static string GetTypeParameter(CodeAttribute attribute)
        {
			var attributeParameters = ParseAttribute(attribute.Value);
			return StripTypeOf(attributeParameters[0]);
        }
    }
#>