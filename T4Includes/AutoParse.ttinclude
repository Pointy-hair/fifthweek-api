<#@ include file="VisualStudioHelper.ttinclude" once="true" #>
<#@ include file="VisualStudioHelper2.ttinclude" once="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    var StrongPropertySuffix = "Object";
    var ParsedAttributeName = "Parsed";
    var TypeAllowsNullAttributeParameterName = "TypeAcceptsNull";
    var IsGuidBase64AttributeParameterName = "IsGuidBase64";

    foreach(UnifiedClass unifiedClass in allClasses)
    {
        var publicProperties = unifiedClass.GetAllPublicGetters();
        var stronglyTypedProperties = publicProperties
            .Select(p => new { Property = p, Attribute = p.Attributes.OfType<CodeAttribute>().FirstOrDefault(_ => _.Name.StartsWith(ParsedAttributeName)) })
            .Where(p => p.Attribute != null)
            .ToList();
        if (stronglyTypedProperties.Count == 0)
        {
            continue;
        }

		var parameters = AutoConstructorParameter.GetParametersForClass(unifiedClass);
		foreach (var parameter in parameters)
        {
			var stonglyTypedProperty = stronglyTypedProperties.SingleOrDefault(_ => _.Property.Name == parameter.AssigneeName);
			if (stonglyTypedProperty != null)
            {
				var codeAttribute = stonglyTypedProperty.Attribute;
				var attributeParameters = ParseAttribute(codeAttribute.Value);
				var strongType = StripTypeOf(attributeParameters[0]);

				parameter.TypeName = strongType;
            }
        }

        unifiedClass.WriteNamespaceAndClass(() => {
#>
public class Parsed
{
<# 
	this.PushIndent(Tab);
	RenderConstructor("Parsed", parameters, this); 
	this.PopIndent();

    // Render the main class here. Companion class follows in next lambda.
    foreach (var parameter in parameters)
    {
#>

	public <#= parameter.TypeName #> <#= parameter.AssigneeName #> { get; private set; }
<#
    }
#>
}
<#
        }, () => { // Extension class. Avoid conflicts between property and type names.
#>
public static <#= unifiedClass.FirstCodeClass.Name #>.Parsed Parse(this <#= unifiedClass.FirstCodeClass.Name #> target)
{
    var modelStateDictionary = new System.Web.Http.ModelBinding.ModelStateDictionary();

<#
    for (var i = 0; i < stronglyTypedProperties.Count; i++)
    {
        var codeAttribute = stronglyTypedProperties[i].Attribute;
        var codeProperty = stronglyTypedProperties[i].Property;
        var typedPropertyName = codeProperty.Name + StrongPropertySuffix;
        var attributeParameters = ParseAttribute(codeAttribute.Value);
        var strongType = StripTypeOf(attributeParameters[0]);
        var isRequired = codeProperty.Attributes.OfType<CodeAttribute>().All(_ => !_.Name.StartsWith(OptionalAttributeName));
        var isRequiredString = isRequired ? "true" : "false";
		var variableName = "parsed" + i;
#>
	<#= strongType #> <#= variableName #> = null;
    if (<#= isRequiredString #> || !<#= strongType #>.IsEmpty(target.<#= codeProperty.Name #>))
    {
        System.Collections.Generic.IReadOnlyCollection<string> errorMessages;
        if (!<#= strongType #>.TryParse(target.<#= codeProperty.Name #>, out <#= variableName #>, out errorMessages))
        {
            var modelState = new System.Web.Http.ModelBinding.ModelState();
            foreach (var errorMessage in errorMessages)
            {
                modelState.Errors.Add(errorMessage);
            }

            modelStateDictionary.Add("<#= codeProperty.Name #>", modelState);
        }
    }

<#
    }
#>
    if (!modelStateDictionary.IsValid)
    {
        throw new Fifthweek.Api.Core.ModelValidationException(modelStateDictionary);
    }

	return new <#= unifiedClass.FirstCodeClass.Name #>.Parsed(
<#
	this.PushIndent(Tab);
	this.PushIndent(Tab);
	var parsedIndex = 0;
	for (var i = 0; i < parameters.Count; i++)
    {
		var parameter = parameters[i];
		var stonglyTypedProperty = stronglyTypedProperties.SingleOrDefault(_ => _.Property.Name == parameter.AssigneeName);
		if (stonglyTypedProperty != null)
        {
			this.Write("parsed" + parsedIndex++);
        }
		else
        {
			this.Write("target." + parameter.AssigneeName);
        }

		if (i < parameters.Count - 1)
        {
			this.WriteLine(",");
        }
		else
        {
			this.WriteLine(");");
        }
    }

	this.PopIndent();
	this.PopIndent();
#>
}    
<#
        });
    }
#>