<#@ include file="VisualStudioHelper.ttinclude" once="true" #>
<#@ include file="VisualStudioHelper2.ttinclude" once="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    var ParsedAttributeName = "Parsed";
	var ParsedCounterpartAttributeName = "ParsedCounterpart";
	var StaticNormalizeMethodName = "Normalize";

    foreach(var unifiedClass in UnifiedClassesInProject.Values)
    {
        var publicProperties = unifiedClass.GetAllPublicGetters();
        var stronglyTypedProperties = publicProperties
            .Select(p => new { Property = p, Attribute = p.Attributes.OfType<CodeAttribute>().FirstOrDefault(_ => _.Name.StartsWith(ParsedAttributeName)) })
            .Where(p => p.Attribute != null)
            .ToList();
        if (stronglyTypedProperties.Count == 0)
        {
            continue;
        }

		var generateCounterpartType = true;
		var counterpartType = unifiedClass.FirstCodeClass.Name + ".Parsed";
		var allAttributes = unifiedClass.GetAllAttributes();
		var parsedCounterpartAttribute = allAttributes.FirstOrDefault(_ => _.Name.StartsWith(ParsedCounterpartAttributeName));
        if (parsedCounterpartAttribute != null)
        {
            var attributeParameters = ParseAttribute(parsedCounterpartAttribute.Value);
			counterpartType = StripTypeOf(attributeParameters[0]);
			generateCounterpartType = false;
        }

		var parameters = AutoConstructorParameter.GetParametersForClass(unifiedClass);
		foreach (var parameter in parameters)
        {
			var stonglyTypedProperty = stronglyTypedProperties.SingleOrDefault(_ => _.Property.Name == parameter.AssigneeName);
			if (stonglyTypedProperty != null)
            {
				var codeAttribute = stonglyTypedProperty.Attribute;
				var attributeParameters = ParseAttribute(codeAttribute.Value);
				var strongType = StripTypeOf(attributeParameters[0]);

				parameter.TypeName = strongType;
            }
        }

        unifiedClass.WriteNamespaceAndClass(() => {
			if (generateCounterpartType)
			{
#>
public class Parsed
{
<# 
	this.PushIndent(Tab);
	RenderConstructor("Parsed", parameters, this); 
	this.PopIndent();

    // Render the main class here. Companion class follows in next lambda.
    foreach (var parameter in parameters)
    {
#>

    public <#= parameter.TypeName #> <#= parameter.AssigneeName #> { get; private set; }
<#
    }
#>
}
<#
			}
        }, () => { // Extension class. Avoid conflicts between property and type names.
#>
public static <#= counterpartType #> Parse(this <#= unifiedClass.FirstCodeClass.Name #> target)
{
    var modelStateDictionary = new System.Web.Http.ModelBinding.ModelStateDictionary();

<#
    for (var i = 0; i < stronglyTypedProperties.Count; i++)
    {
        var codeAttribute = stronglyTypedProperties[i].Attribute;
        var codeProperty = stronglyTypedProperties[i].Property;
        var attributeParameters = ParseAttribute(codeAttribute.Value);
        var strongType = StripTypeOf(attributeParameters[0]);
        var isRequired = codeProperty.Attributes.OfType<CodeAttribute>().All(_ => !_.Name.StartsWith(OptionalAttributeName));
		var variableName = "parsed" + i;
		var strongTypeUnifiedClass = unifiedClass.ResolveUnifiedClass(strongType);
		var canNormalize = strongTypeUnifiedClass.GetAllPublicMethods().Any(_ => _.IsShared && _.Name == StaticNormalizeMethodName);

		this.PushIndent(Tab);
		RenderParseBlock(
			strongType, 
			codeProperty.Name, 
			variableName, 
			isRequired, 
			canNormalize, 
			IsNullablePrimitiveType(codeProperty.Type.CodeType), 
			IsReferenceType(codeProperty.Type.CodeType), 
			this);
		this.PopIndent();
    }
#>
    if (!modelStateDictionary.IsValid)
    {
        throw new Fifthweek.Api.Core.ModelValidationException(modelStateDictionary);
    }

	return new <#= counterpartType #>(
<#
	this.PushIndent(Tab);
	this.PushIndent(Tab);
	var parsedIndex = 0;
	for (var i = 0; i < parameters.Count; i++)
    {
		var parameter = parameters[i];
		var stonglyTypedProperty = stronglyTypedProperties.SingleOrDefault(_ => _.Property.Name == parameter.AssigneeName);
		if (stonglyTypedProperty != null)
        {
			this.Write("parsed" + parsedIndex++);
        }
		else
        {
			this.Write("target." + parameter.AssigneeName);
        }

		if (i < parameters.Count - 1)
        {
			this.WriteLine(",");
        }
		else
        {
			this.WriteLine(");");
        }
    }

	this.PopIndent();
	this.PopIndent();
#>
}    
<#
        });
    }
#>
<#+

	public static void RenderParseBlock(
		string strongType, 
		string property, 
		string variable, 
		bool isRequired, 
		bool canNormalize, 
		bool isNullableValue, 
		bool isReferenceType, 
		TextTransformation output)
	{
		var newModelState = "var modelState = new System.Web.Http.ModelBinding.ModelState();";
		var addModelState = string.Format("modelStateDictionary.Add(\"{0}\", modelState);",  property);

		output.WriteLine(string.Format("{0} {1} = null;", strongType, variable));

		if (isReferenceType)
        {
			output.WriteLine(string.Format("if (target.{0} != null)", property));
			output.WriteLine("{");
			output.PushIndent(Tab);
        }

		var variableAccessor = "target." + (isNullableValue ? property + ".Value" : property);
		if (canNormalize)
        {
			var oldVariableAccessor = variableAccessor;
			variableAccessor = variable + "Normalized";
			output.WriteLine(string.Format("var {0} = {1}.Normalize({2});", variableAccessor, strongType, oldVariableAccessor));
			
			// Cannot be certain what type the normalized value is, so assume it's a reference type and needs null check.
			output.WriteLine(string.Format("if ({0} != null)", variableAccessor));
			output.WriteLine("{");
			output.PushIndent(Tab);
        }

		output.WriteLine(string.Format("System.Collections.Generic.IReadOnlyCollection<string> {0}Errors;", variable));
		output.WriteLine(string.Format("if (!{0}.TryParse({1}, out {2}, out {2}Errors))", strongType, variableAccessor, variable));
		output.WriteLine("{");
		output.PushIndent(Tab);
        
		output.WriteLine(newModelState);
		output.WriteLine(string.Format("foreach (var errorMessage in {0}Errors)", variable));
        output.WriteLine("{");
		output.PushIndent(Tab);
		output.WriteLine("modelState.Errors.Add(errorMessage);");
        output.PopIndent();
		output.WriteLine("}");
		output.WriteLine("");
        output.WriteLine(addModelState);

		output.PopIndent();
		output.WriteLine("}");

		if (canNormalize) 
        {
			output.PopIndent();
			output.WriteLine("}");

			// Cannot be certain what type the normalized value is, so assume it's a reference type and needs null check.
			if (isRequired)
			{
				RenderElseValueRequired(newModelState, addModelState, output);
			}
		}

		if (isReferenceType)
        {
			output.PopIndent();
			output.WriteLine("}");

			if (isRequired)
			{
				RenderElseValueRequired(newModelState, addModelState, output);
			}
        }

		output.WriteLine("");
	}

	public static void RenderElseValueRequired(string newModelState, string addModelState, TextTransformation output)
	{
		output.WriteLine("else");
		output.WriteLine("{");
		output.PushIndent(Tab);
		output.WriteLine(newModelState);
		output.WriteLine("modelState.Errors.Add(\"Value required\");");
		output.WriteLine(addModelState);
		output.PopIndent();
		output.WriteLine("}");
	}

#>